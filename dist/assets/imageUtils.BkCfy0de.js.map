{"version":3,"file":"imageUtils.BkCfy0de.js","sources":["../../src/utils/imageUtils.js"],"sourcesContent":["/**\n * Utilities for image handling and placeholder generation\n */\n\n/**\n * Generates a fallback gradient image for a playlist or section\n * @param {string} type - The type of placeholder ('liked', 'all', 'new', 'random', 'album', 'playlist')\n * @param {number} width - Image width\n * @param {number} height - Image height\n * @returns {string} - Data URL of the generated image\n */\nexport const generatePlaceholderImage = (type = 'album', width = 300, height = 300) => {\n  \n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const ctx = canvas.getContext('2d');\n  \n  \n  const gradients = {\n    liked: {\n      colors: ['#ff5252', '#d32f2f'],\n      shape: 'radial'\n    },\n    all: {\n      colors: ['#3f51b5', '#1a237e'],\n      shape: 'linear'\n    },\n    new: {\n      colors: ['#43a047', '#1b5e20'],\n      shape: 'linear'\n    },\n    random: {\n      colors: ['#7b1fa2', '#4a148c'],\n      shape: 'radial'\n    },\n    album: {\n      colors: ['#424242', '#212121'],\n      shape: 'linear'\n    },\n    playlist: {\n      colors: ['#546e7a', '#263238'],\n      shape: 'linear'\n    }\n  };\n  \n  \n  const gradientConfig = gradients[type] || gradients.album;\n  let gradient;\n  \n  if (gradientConfig.shape === 'radial') {\n    gradient = ctx.createRadialGradient(\n      width / 2,\n      height / 2,\n      0,\n      width / 2,\n      height / 2,\n      width / 1.5\n    );\n  } else {\n    gradient = ctx.createLinearGradient(0, 0, width, height);\n  }\n  \n  gradient.addColorStop(0, gradientConfig.colors[0]);\n  gradient.addColorStop(1, gradientConfig.colors[1]);\n  \n  \n  ctx.fillStyle = gradient;\n  ctx.fillRect(0, 0, width, height);\n  \n  \n  if (type === 'liked') {\n    \n    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';\n    ctx.beginPath();\n    const heartSize = width / 2;\n    const x = width / 2;\n    const y = height / 2;\n    \n    \n    ctx.moveTo(x, y - heartSize / 4);\n    ctx.bezierCurveTo(\n      x, y - heartSize / 2,\n      x - heartSize / 2, y - heartSize / 2,\n      x - heartSize / 2, y - heartSize / 4\n    );\n    ctx.bezierCurveTo(\n      x - heartSize / 2, y + heartSize / 4,\n      x, y + heartSize / 2,\n      x, y + heartSize / 2\n    );\n    ctx.bezierCurveTo(\n      x, y + heartSize / 2,\n      x + heartSize / 2, y + heartSize / 4,\n      x + heartSize / 2, y - heartSize / 4\n    );\n    ctx.bezierCurveTo(\n      x + heartSize / 2, y - heartSize / 2,\n      x, y - heartSize / 2,\n      x, y - heartSize / 4\n    );\n    \n    ctx.fill();\n  } else if (type === 'random') {\n    \n    for (let i = 0; i < 8; i++) {\n      ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.2})`;\n      ctx.beginPath();\n      ctx.arc(\n        Math.random() * width,\n        Math.random() * height,\n        Math.random() * width / 8 + 10,\n        0,\n        Math.PI * 2\n      );\n      ctx.fill();\n    }\n  } else if (type === 'new') {\n    \n    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';\n    const size = width / 6;\n    const x = width / 2 - size / 2;\n    const y = height / 2 - size / 2;\n    \n    \n    ctx.fillRect(x - size, y + size / 2 - size / 6, size * 3, size / 3);\n    \n    ctx.fillRect(x + size / 2 - size / 6, y - size, size / 3, size * 3);\n  } else if (type === 'all') {\n    \n    for (let i = 0; i < 5; i++) {\n      ctx.fillStyle = `rgba(255, 255, 255, ${0.1 + (i * 0.02)})`;\n      ctx.fillRect(width / 4, height / 3 + (i * height / 15), width / 2, height / 30);\n    }\n  } else {\n    \n    for (let i = 0; i < 3; i++) {\n      ctx.fillStyle = `rgba(255, 255, 255, ${0.1 - (i * 0.03)})`;\n      ctx.fillRect(width / 4, height / 4 + (i * height / 12), width / 2, height / 15);\n    }\n  }\n  \n  \n  return canvas.toDataURL('image/jpeg', 0.9);\n};\n\n/**\n * Get a cover image with fallback to generated placeholder\n * @param {string} path - The image path\n * @param {string} type - The type of placeholder if needed\n * @returns {string} - The image URL (original or generated)\n */\nexport const getCoverWithFallback = (path, type = 'album') => {\n  \n  if (!path || path === '') {\n    \n    return generatePlaceholderImage(type || 'album');\n  }\n  \n  \n  if (typeof path !== 'string') {\n    console.warn('getCoverWithFallback: path is not a string', path);\n    return generatePlaceholderImage(type || 'album');\n  }\n  \n  \n  if (path && !path.startsWith('/') && !path.startsWith('http')) {\n    path = '/' + path;\n  }\n  \n  try {\n    \n    const isSystemFile = path && (\n      path.includes('/uploads/system/') || \n      path.includes('/static/uploads/system/')\n    );\n    \n    if (isSystemFile) {\n      \n      const fallbacks = {\n        'like_playlist.jpg': generatePlaceholderImage('liked'),\n        'all_tracks.jpg': generatePlaceholderImage('all'),\n        'random_tracks.jpg': generatePlaceholderImage('random'),\n        'album_placeholder.jpg': generatePlaceholderImage('album'),\n        'playlist_placeholder.jpg': generatePlaceholderImage('playlist')\n      };\n      \n      \n      for (const [filename, fallback] of Object.entries(fallbacks)) {\n        if (path.includes(filename)) {\n          \n          return path;\n        }\n      }\n    }\n    \n    return path;\n  } catch (error) {\n    console.error('Error in getCoverWithFallback:', error);\n    return generatePlaceholderImage(type || 'album');\n  }\n};\n\n/**\n * Извлекает основной цвет из изображения\n * @param {string} imgSrc - Путь к изображению\n * @param {function} callback - Функция для возврата извлеченного цвета\n */\nexport const extractDominantColor = (imgSrc, callback) => {\n  const img = new Image();\n  img.crossOrigin = 'Anonymous';\n  \n  img.onload = () => {\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    canvas.width = img.width;\n    canvas.height = img.height;\n    \n    context.drawImage(img, 0, 0);\n    \n    \n    const centerX = img.width / 2;\n    const centerY = img.height / 2;\n    const data = context.getImageData(centerX, centerY, 1, 1).data;\n    \n    \n    callback(`${data[0]}, ${data[1]}, ${data[2]}`);\n  };\n  \n  img.onerror = () => {\n    console.error(`Failed to load image: ${imgSrc}`);\n    callback(null);\n  };\n  \n  img.src = imgSrc;\n};\n\n/**\n * Проверяет поддержку WebP в браузере\n * @returns {Promise<boolean>} true если WebP поддерживается\n */\nexport const isWebPSupported = async () => {\n  \n  if (!self.createImageBitmap) return false;\n  \n  \n  const webpData = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=';\n  \n  try {\n    \n    const blob = await fetch(webpData).then(r => r.blob());\n    return createImageBitmap(blob).then(() => true, () => false);\n  } catch (e) {\n    return false;\n  }\n};\n\n/**\n * Конвертирует изображение в формат WebP при поддержке\n * @param {string} url - Исходный URL изображения\n * @param {Object} options - Настройки конвертации\n * @param {number} options.quality - Качество WebP (0-1, по умолчанию 0.8)\n * @param {number} options.maxWidth - Максимальная ширина (сохраняет пропорции)\n * @param {boolean} options.cacheResults - Кэшировать ли результаты в sessionStorage\n * @returns {Promise<string>} URL изображения в WebP или исходный если конвертация не удалась\n */\nexport const convertToWebP = async (url, options = {}) => {\n  \n  if (!url || \n      url.startsWith('data:') || \n      url.includes('.svg') || \n      url.includes('.gif') || \n      url.includes('.webp')) {\n    return url;\n  }\n  \n  \n  const {\n    quality = 0.8,\n    maxWidth = 1200,\n    cacheResults = true\n  } = options;\n  \n  \n  const cacheKey = `webp-cache-${url}-${quality}-${maxWidth}`;\n  \n  \n  if (cacheResults && 'sessionStorage' in window) {\n    try {\n      const cached = sessionStorage.getItem(cacheKey);\n      if (cached) {\n        return cached;\n      }\n    } catch (e) {\n      console.warn('Failed to read from sessionStorage', e);\n    }\n  }\n  \n  \n  const webpSupported = await isWebPSupported();\n  if (!webpSupported) {\n    return url;\n  }\n  \n  \n  return new Promise((resolve) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    \n    img.onload = () => {\n      \n      let width = img.width;\n      let height = img.height;\n      \n      if (width > maxWidth) {\n        const ratio = maxWidth / width;\n        width = maxWidth;\n        height = Math.round(height * ratio);\n      }\n      \n      \n      const canvas = document.createElement('canvas');\n      canvas.width = width;\n      canvas.height = height;\n      \n      const ctx = canvas.getContext('2d');\n      ctx.drawImage(img, 0, 0, width, height);\n      \n      \n      try {\n        const webpUrl = canvas.toDataURL('image/webp', quality);\n        \n        \n        if (cacheResults && 'sessionStorage' in window) {\n          try {\n            sessionStorage.setItem(cacheKey, webpUrl);\n          } catch (e) {\n            console.warn('Failed to write to sessionStorage', e);\n          }\n        }\n        \n        resolve(webpUrl);\n      } catch (e) {\n        console.warn('Failed to convert image to WebP', e);\n        resolve(url);\n      }\n    };\n    \n    img.onerror = () => {\n      console.warn(`Failed to load image: ${url}`);\n      resolve(url);\n    };\n    \n    img.src = url;\n  });\n};\n\n/**\n * Utils for image optimization and handling\n */\n\n\nconst optimizedImageCache = new Map();\n\n/**\n * Optimize an image by loading it and potentially applying transformations\n * @param {string} imageSrc - Source URL of the image\n * @param {Object} options - Optimization options\n * @param {number} options.quality - JPEG quality (0-1)\n * @param {number} options.maxWidth - Maximum width of the image\n * @param {boolean} options.cacheResults - Whether to cache results\n * @returns {Promise<{src: string, width: number, height: number}>}\n */\nexport const optimizeImage = async (imageSrc, options = {}) => {\n  const {\n    quality = 0.85,\n    maxWidth = 1920,\n    cacheResults = true\n  } = options;\n\n  \n  const cacheKey = `${imageSrc}-${maxWidth}-${quality}`;\n  if (cacheResults && optimizedImageCache.has(cacheKey)) {\n    return optimizedImageCache.get(cacheKey);\n  }\n\n  \n  if (\n    !imageSrc ||\n    (imageSrc.startsWith('http') && !imageSrc.includes(window.location.host)) ||\n    !isImageUrl(imageSrc)\n  ) {\n    const result = { src: imageSrc, width: 0, height: 0 };\n    if (cacheResults) optimizedImageCache.set(cacheKey, result);\n    return result;\n  }\n\n  try {\n    \n    const img = await loadImage(imageSrc);\n    const { naturalWidth: width, naturalHeight: height } = img;\n\n    \n    if (width <= maxWidth) {\n      const result = { src: imageSrc, width, height };\n      if (cacheResults) optimizedImageCache.set(cacheKey, result);\n      return result;\n    }\n\n    \n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    \n    \n    const aspectRatio = width / height;\n    const newWidth = maxWidth;\n    const newHeight = Math.round(newWidth / aspectRatio);\n    \n    \n    canvas.width = newWidth;\n    canvas.height = newHeight;\n    \n    \n    ctx.drawImage(img, 0, 0, newWidth, newHeight);\n    \n    \n    const webpSupported = supportsWebP();\n    const format = webpSupported ? 'image/webp' : 'image/jpeg';\n    const optimizedSrc = canvas.toDataURL(format, quality);\n    \n    const result = {\n      src: optimizedSrc,\n      width: newWidth,\n      height: newHeight\n    };\n\n    \n    if (cacheResults) {\n      optimizedImageCache.set(cacheKey, result);\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Error optimizing image:', error);\n    \n    return { src: imageSrc, width: 0, height: 0 };\n  }\n};\n\n/**\n * Preloads an image and returns a promise\n * @param {string} src - Image source URL\n * @returns {Promise<HTMLImageElement>}\n */\nexport const loadImage = (src) => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = 'anonymous';\n    \n    img.onload = () => resolve(img);\n    img.onerror = (err) => reject(err);\n    \n    img.src = src;\n  });\n};\n\n/**\n * Check if a URL points to an image based on extension\n * @param {string} url - URL to check\n * @returns {boolean}\n */\nexport const isImageUrl = (url) => {\n  if (!url) return false;\n  \n  const imageExtensions = [\n    '.jpg', '.jpeg', '.png', '.gif', '.bmp', \n    '.webp', '.svg', '.tiff', '.avif'\n  ];\n  \n  const urlLower = url.toLowerCase();\n  return imageExtensions.some(ext => urlLower.endsWith(ext)) || \n         urlLower.includes('/image/') ||\n         urlLower.includes('image_url=');\n};\n\n/**\n * Detects whether the browser supports WebP\n * @returns {boolean}\n */\nexport const supportsWebP = () => {\n  \n  if (typeof supportsWebP.cached !== 'undefined') {\n    return supportsWebP.cached;\n  }\n  \n  const elem = document.createElement('canvas');\n  \n  if (elem.getContext && elem.getContext('2d')) {\n    \n    supportsWebP.cached = elem.toDataURL('image/webp').indexOf('data:image/webp') === 0;\n  } else {\n    \n    supportsWebP.cached = false;\n  }\n  \n  return supportsWebP.cached;\n};\n\n/**\n * Formats an image URL for optimal loading\n * @param {string} url - Original image URL\n * @param {Object} options - Formatting options\n * @returns {string}\n */\nexport const formatImageUrl = (url, options = {}) => {\n  if (!url) return '';\n  \n  const {\n    width,\n    height,\n    quality = 90,\n    format\n  } = options;\n  \n  \n  if (url.includes('?') || (url.startsWith('http') && !url.includes(window.location.host))) {\n    return url;\n  }\n  \n  \n  let formattedUrl = url;\n  \n  \n  const params = [];\n  if (width) params.push(`w=${width}`);\n  if (height) params.push(`h=${height}`);\n  if (quality) params.push(`q=${quality}`);\n  if (format) params.push(`fm=${format}`);\n  \n  if (params.length > 0) {\n    formattedUrl += `${url.includes('?') ? '&' : '?'}${params.join('&')}`;\n  }\n  \n  return formattedUrl;\n};\n\n/**\n * Generates a data URL for a placeholder image\n * @param {number} width - Width of the placeholder\n * @param {number} height - Height of the placeholder\n * @param {string} text - Optional text to display on the placeholder\n * @param {string} bgColor - Background color (hex, rgb, etc)\n * @param {string} textColor - Text color (hex, rgb, etc)\n * @returns {string} - Data URL for the placeholder image\n */\nexport const generatePlaceholder = (width = 300, height = 150, text = '', bgColor = '#e0e0e0', textColor = '#666666') => {\n  try {\n    \n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    \n    \n    ctx.fillStyle = bgColor;\n    ctx.fillRect(0, 0, width, height);\n    \n    \n    if (text) {\n      ctx.fillStyle = textColor;\n      ctx.font = `bold ${Math.floor(height / 10)}px Arial, sans-serif`;\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      \n      \n      const maxWidth = width * 0.8;\n      let displayText = text;\n      let textWidth = ctx.measureText(displayText).width;\n      \n      if (textWidth > maxWidth) {\n        \n        let i = displayText.length;\n        while (textWidth > maxWidth && i > 0) {\n          i--;\n          displayText = displayText.substring(0, i) + '...';\n          textWidth = ctx.measureText(displayText).width;\n        }\n      }\n      \n      ctx.fillText(displayText, width / 2, height / 2);\n    }\n    \n    \n    const dimensionsText = `${width}×${height}`;\n    ctx.font = `${Math.floor(height / 20)}px Arial, sans-serif`;\n    ctx.fillText(dimensionsText, width / 2, height - Math.floor(height / 15));\n    \n    \n    return canvas.toDataURL('image/png');\n  } catch (error) {\n    console.error('Error generating placeholder image:', error);\n    \n    return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 ${width} ${height}'%3E%3Crect width='${width}' height='${height}' fill='%23e0e0e0'/%3E%3Ctext x='50%25' y='50%25' font-family='Arial' font-size='16' text-anchor='middle' fill='%23666666'%3E${width}×${height}%3C/text%3E%3C/svg%3E`;\n  }\n}; "],"names":["generatePlaceholderImage","type","width","height","canvas","document","createElement","ctx","getContext","gradients","liked","colors","shape","all","new","random","album","playlist","gradientConfig","gradient","createRadialGradient","createLinearGradient","addColorStop","fillStyle","fillRect","beginPath","heartSize","x","y","moveTo","bezierCurveTo","fill","i","Math","arc","PI","size","toDataURL","getCoverWithFallback","path","startsWith","includes","fallbacks","filename","fallback","Object","entries","error","extractDominantColor","imgSrc","callback","img","Image","crossOrigin","onload","context","drawImage","centerX","centerY","data","getImageData","onerror","src","optimizedImageCache","Map","optimizeImage","async","imageSrc","options","quality","maxWidth","cacheResults","cacheKey","has","get","window","location","host","isImageUrl","result","set","loadImage","naturalWidth","naturalHeight","aspectRatio","newWidth","newHeight","round","format","supportsWebP","Promise","resolve","reject","err","url","imageExtensions","urlLower","toLowerCase","some","endsWith","ext","cached","elem","indexOf","generatePlaceholder","text","bgColor","textColor","font","floor","textAlign","textBaseline","displayText","textWidth","measureText","length","substring","fillText","dimensionsText"],"mappings":"AAWO,MAAMA,EAA2BA,CAACC,EAAO,QAASC,EAAQ,IAAKC,EAAS,OAEvEC,MAAAA,EAASC,SAASC,cAAc,UACtCF,EAAOF,MAAQA,EACfE,EAAOD,OAASA,EACVI,MAAAA,EAAMH,EAAOI,WAAW,MAGxBC,EAAY,CAChBC,MAAO,CACLC,OAAQ,CAAC,UAAW,WACpBC,MAAO,UAETC,IAAK,CACHF,OAAQ,CAAC,UAAW,WACpBC,MAAO,UAETE,IAAK,CACHH,OAAQ,CAAC,UAAW,WACpBC,MAAO,UAETG,OAAQ,CACNJ,OAAQ,CAAC,UAAW,WACpBC,MAAO,UAETI,MAAO,CACLL,OAAQ,CAAC,UAAW,WACpBC,MAAO,UAETK,SAAU,CACRN,OAAQ,CAAC,UAAW,WACpBC,MAAO,WAKLM,EAAiBT,EAAUR,IAASQ,EAAUO,MAChDG,IAAAA,EAuBJ,GApBEA,EAD2B,WAAzBD,EAAeN,MACNL,EAAIa,qBACblB,EAAQ,EACRC,EAAS,EACT,EACAD,EAAQ,EACRC,EAAS,EACTD,EAAQ,KAGCK,EAAIc,qBAAqB,EAAG,EAAGnB,EAAOC,GAGnDgB,EAASG,aAAa,EAAGJ,EAAeP,OAAO,IAC/CQ,EAASG,aAAa,EAAGJ,EAAeP,OAAO,IAG/CJ,EAAIgB,UAAYJ,EAChBZ,EAAIiB,SAAS,EAAG,EAAGtB,EAAOC,GAGb,UAATF,EAAkB,CAEpBM,EAAIgB,UAAY,2BAChBhB,EAAIkB,YACJ,MAAMC,EAAYxB,EAAQ,EACpByB,EAAIzB,EAAQ,EACZ0B,EAAIzB,EAAS,EAGnBI,EAAIsB,OAAOF,EAAGC,EAAIF,EAAY,GAC9BnB,EAAIuB,cACFH,EAAGC,EAAIF,EAAY,EACnBC,EAAID,EAAY,EAAGE,EAAIF,EAAY,EACnCC,EAAID,EAAY,EAAGE,EAAIF,EAAY,GAErCnB,EAAIuB,cACFH,EAAID,EAAY,EAAGE,EAAIF,EAAY,EACnCC,EAAGC,EAAIF,EAAY,EACnBC,EAAGC,EAAIF,EAAY,GAErBnB,EAAIuB,cACFH,EAAGC,EAAIF,EAAY,EACnBC,EAAID,EAAY,EAAGE,EAAIF,EAAY,EACnCC,EAAID,EAAY,EAAGE,EAAIF,EAAY,GAErCnB,EAAIuB,cACFH,EAAID,EAAY,EAAGE,EAAIF,EAAY,EACnCC,EAAGC,EAAIF,EAAY,EACnBC,EAAGC,EAAIF,EAAY,GAGrBnB,EAAIwB,MAAK,MACX,GAAoB,WAAT9B,EAET,IAAA,IAAS+B,EAAI,EAAGA,EAAI,EAAGA,IACrBzB,EAAIgB,UAAY,uBAAuC,GAAhBU,KAAKlB,YAC5CR,EAAIkB,YACJlB,EAAI2B,IACFD,KAAKlB,SAAWb,EAChB+B,KAAKlB,SAAWZ,EAChB8B,KAAKlB,SAAWb,EAAQ,EAAI,GAC5B,EACU,EAAV+B,KAAKE,IAEP5B,EAAIwB,YAER,GAAoB,QAAT9B,EAAgB,CAEzBM,EAAIgB,UAAY,2BAChB,MAAMa,EAAOlC,EAAQ,EACfyB,EAAIzB,EAAQ,EAAIkC,EAAO,EACvBR,EAAIzB,EAAS,EAAIiC,EAAO,EAG1BZ,EAAAA,SAASG,EAAIS,EAAMR,EAAIQ,EAAO,EAAIA,EAAO,EAAU,EAAPA,EAAUA,EAAO,GAE7DZ,EAAAA,SAASG,EAAIS,EAAO,EAAIA,EAAO,EAAGR,EAAIQ,EAAMA,EAAO,EAAU,EAAPA,EAAQ,MACpE,GAAoB,QAATnC,EAET,IAAA,IAAS+B,EAAI,EAAGA,EAAI,EAAGA,IACrBzB,EAAIgB,UAAY,uBAAuB,GAAW,IAAJS,KAC1CR,EAAAA,SAAStB,EAAQ,EAAGC,EAAS,EAAK6B,EAAI7B,EAAS,GAAKD,EAAQ,EAAGC,EAAS,SAI9E,IAAA,IAAS6B,EAAI,EAAGA,EAAI,EAAGA,IACrBzB,EAAIgB,UAAY,uBAAuB,GAAW,IAAJS,KAC1CR,EAAAA,SAAStB,EAAQ,EAAGC,EAAS,EAAK6B,EAAI7B,EAAS,GAAKD,EAAQ,EAAGC,EAAS,IAKzEC,OAAAA,EAAOiC,UAAU,aAAc,KAS3BC,EAAuBA,CAACC,EAAMtC,EAAO,WAE5C,IAACsC,GAAiB,KAATA,EAEJvC,OAAAA,EAAyBC,GAAQ,SAItC,GAAgB,iBAATsC,EAEFvC,OAAAA,EAAyBC,GAAQ,UAItCsC,GAASA,EAAKC,WAAW,MAASD,EAAKC,WAAW,UACpDD,EAAO,IAAMA,GAGX,IAOF,GALqBA,IACnBA,EAAKE,SAAS,qBACdF,EAAKE,SAAS,4BAGE,CAEhB,MAAMC,EAAY,CAChB,oBAAqB1C,EAAyB,SAC9C,iBAAkBA,EAAyB,OAC3C,oBAAqBA,EAAyB,UAC9C,wBAAyBA,EAAyB,SAClD,2BAA4BA,EAAyB,aAIvD,IAAA,MAAY2C,EAAUC,KAAaC,OAAOC,QAAQJ,GAC5CH,GAAAA,EAAKE,SAASE,GAETJ,OAAAA,CAEX,CAGKA,OAAAA,QACAQ,GAEA/C,OAAAA,EAAyBC,GAAQ,QAAO,GAStC+C,EAAuBA,CAACC,EAAQC,KACrCC,MAAAA,EAAM,IAAIC,MAChBD,EAAIE,YAAc,YAElBF,EAAIG,OAAS,KACLlD,MAAAA,EAASC,SAASC,cAAc,UAChCiD,EAAUnD,EAAOI,WAAW,MAClCJ,EAAOF,MAAQiD,EAAIjD,MACnBE,EAAOD,OAASgD,EAAIhD,OAEZqD,EAAAA,UAAUL,EAAK,EAAG,GAGpBM,MAAAA,EAAUN,EAAIjD,MAAQ,EACtBwD,EAAUP,EAAIhD,OAAS,EACvBwD,EAAOJ,EAAQK,aAAaH,EAASC,EAAS,EAAG,GAAGC,KAG1DT,EAAS,GAAGS,EAAK,OAAOA,EAAK,OAAOA,EAAK,OAG3CR,EAAIU,QAAU,KAEZX,EAAS,OAGXC,EAAIW,IAAMb,GAgINc,MAA0BC,IAWnBC,EAAgBC,MAAOC,EAAUC,EAAU,MAChD,MAAAC,QACJA,EAAU,IAAAC,SACVA,EAAW,KAAAC,aACXA,GAAe,GACbH,EAGEI,EAAW,GAAGL,KAAYG,KAAYD,IAC5C,GAAIE,GAAgBR,EAAoBU,IAAID,GACnCT,OAAAA,EAAoBW,IAAIF,GAIjC,IACGL,GACAA,EAAS3B,WAAW,UAAY2B,EAAS1B,SAASkC,OAAOC,SAASC,QAClEC,EAAWX,GACZ,CACA,MAAMY,EAAS,CAAEjB,IAAKK,EAAUjE,MAAO,EAAGC,OAAQ,GAE3C4E,OADHR,GAAcR,EAAoBiB,IAAIR,EAAUO,GAC7CA,CAAAA,CAGL,IAEI5B,MAAAA,QAAY8B,EAAUd,IACpBe,aAAchF,EAAOiF,cAAehF,GAAWgD,EAGvD,GAAIjD,GAASoE,EAAU,CACrB,MAAMS,EAAS,CAAEjB,IAAKK,EAAUjE,QAAOC,UAEhC4E,OADHR,GAAcR,EAAoBiB,IAAIR,EAAUO,GAC7CA,CAAAA,CAIH3E,MAAAA,EAASC,SAASC,cAAc,UAChCC,EAAMH,EAAOI,WAAW,MAGxB4E,EAAclF,EAAQC,EACtBkF,EAAWf,EACXgB,EAAYrD,KAAKsD,MAAMF,EAAWD,GAGxChF,EAAOF,MAAQmF,EACfjF,EAAOD,OAASmF,EAGhB/E,EAAIiD,UAAUL,EAAK,EAAG,EAAGkC,EAAUC,GAGnC,MACME,EADgBC,IACS,aAAe,aAGxCV,EAAS,CACbjB,IAHmB1D,EAAOiC,UAAUmD,EAAQnB,GAI5CnE,MAAOmF,EACPlF,OAAQmF,GAQHP,OAJHR,GACkBS,EAAAA,IAAIR,EAAUO,GAG7BA,QACAhC,GAGA,MAAA,CAAEe,IAAKK,EAAUjE,MAAO,EAAGC,OAAQ,EAAE,GASnC8E,EAAqBnB,GACzB,IAAI4B,QAAQ,CAACC,EAASC,KACrBzC,MAAAA,EAAM,IAAIC,MAChBD,EAAIE,YAAc,YAEdC,EAAAA,OAAS,IAAMqC,EAAQxC,GACvBU,EAAAA,QAAmB+B,GAAAA,EAAOC,GAE9B1C,EAAIW,IAAMA,IASDgB,EAAsBgB,IAC7B,IAACA,EAAY,OAAA,EAEXC,MAKAC,EAAWF,EAAIG,cACrB,MANwB,CACtB,OAAQ,QAAS,OAAQ,OAAQ,OACjC,QAAS,OAAQ,QAAS,SAILC,KAAYF,GAAAA,EAASG,SAASC,KAC9CJ,EAASvD,SAAS,YAClBuD,EAASvD,SAAS,eAOdgD,EAAeA,KAEtB,QAA+B,IAAxBA,EAAaY,OACtB,OAAOZ,EAAaY,OAGhBC,MAAAA,EAAOjG,SAASC,cAAc,UAUpC,OARIgG,EAAK9F,YAAc8F,EAAK9F,WAAW,MAErCiF,EAAaY,OAAqE,IAA5DC,EAAKjE,UAAU,cAAckE,QAAQ,mBAG3Dd,EAAaY,QAAS,EAGjBZ,EAAaY,QAkDTG,EAAsBA,CAACtG,EAAQ,IAAKC,EAAS,IAAKsG,EAAO,GAAIC,EAAU,UAAWC,EAAY,aACrG,IAEIvG,MAAAA,EAASC,SAASC,cAAc,UACtCF,EAAOF,MAAQA,EACfE,EAAOD,OAASA,EACVI,MAAAA,EAAMH,EAAOI,WAAW,MAO9B,GAJAD,EAAIgB,UAAYmF,EAChBnG,EAAIiB,SAAS,EAAG,EAAGtB,EAAOC,GAGtBsG,EAAM,CACRlG,EAAIgB,UAAYoF,EAChBpG,EAAIqG,KAAO,QAAQ3E,KAAK4E,MAAM1G,EAAS,0BACvCI,EAAIuG,UAAY,SAChBvG,EAAIwG,aAAe,SAGnB,MAAMzC,EAAmB,GAARpE,EACjB,IAAI8G,EAAcP,EACdQ,EAAY1G,EAAI2G,YAAYF,GAAa9G,MAE7C,GAAI+G,EAAY3C,EAAU,CAExB,IAAItC,EAAIgF,EAAYG,OACbF,KAAAA,EAAY3C,GAAYtC,EAAI,GACjCA,IACAgF,EAAcA,EAAYI,UAAU,EAAGpF,GAAK,MAChCzB,EAAAA,EAAI2G,YAAYF,GAAa9G,KAC3C,CAGFK,EAAI8G,SAASL,EAAa9G,EAAQ,EAAGC,EAAS,EAAC,CAIjD,MAAMmH,EAAiB,GAAGpH,KAASC,IAK5BC,OAJPG,EAAIqG,KAAO,GAAG3E,KAAK4E,MAAM1G,EAAS,0BAC9BkH,EAAAA,SAASC,EAAgBpH,EAAQ,EAAGC,EAAS8B,KAAK4E,MAAM1G,EAAS,KAG9DC,EAAOiC,UAAU,mBACjBU,GAGP,MAAO,uEAAuE7C,cAAkBC,mBAAwBD,KAASC,uBAA4BD,cAAkBC,iIAAsID,KAASC,wBAAM"}